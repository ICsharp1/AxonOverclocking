// Axon Overclocking - Brain Training Application Database Schema
// This schema defines the complete database structure for the brain training platform
// with NextAuth v5 integration and JSON-based extensibility pattern

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================================================
// CORE MODEL 1: USER
// ============================================================================
// User accounts with NextAuth v5 support
// Supports both credential-based and OAuth authentication
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  password      String? // Optional for OAuth users
  name          String?
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts         Account[]
  sessions         Session[]
  trainingSessions TrainingSession[]
  userProgress     UserProgress[]
  contentUsage     ContentUsage[]
}

// ============================================================================
// CORE MODEL 2: TRAINING MODULE
// ============================================================================
// Defines available training modules (e.g., Word Memory, Pattern Recognition)
// Uses JSON configuration field for extensibility without schema migrations
model TrainingModule {
  id            String   @id @default(cuid())
  name          String // Display name: "Word Memory"
  slug          String   @unique // URL-safe identifier: "word-memory"
  description   String // Brief description of the training
  category      String // Category: "memory", "attention", "processing-speed"
  configuration Json // Training-specific config (difficulty levels, timing, etc.)
  isActive      Boolean  @default(true) // Allow disabling modules without deletion
  createdAt     DateTime @default(now())

  // Relations
  trainingSessions TrainingSession[]
  userProgress     UserProgress[]
}

// ============================================================================
// CORE MODEL 3: TRAINING SESSION
// ============================================================================
// Individual training session records with results
// JSON fields allow storing training-specific data without schema changes
model TrainingSession {
  id               String   @id @default(cuid())
  userId           String
  trainingModuleId String
  configuration    Json // Snapshot of config used for this session
  results          Json // Training-specific results data
  score            Float // Primary score (0-100)
  accuracy         Float? // Optional accuracy metric (0-100)
  duration         Int // Duration in seconds
  performanceLevel String // "excellent", "good", "fair", "poor"
  status           String // "completed", "abandoned"
  createdAt        DateTime @default(now())

  // Relations
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  trainingModule TrainingModule @relation(fields: [trainingModuleId], references: [id])

  // Performance optimization for user session history queries
  @@index([userId, createdAt])
}

// ============================================================================
// CORE MODEL 4: USER PROGRESS
// ============================================================================
// Aggregated progress tracking per user per training module
// Automatically updated when sessions are completed
model UserProgress {
  id                String    @id @default(cuid())
  userId            String
  trainingModuleId  String
  totalSessions     Int       @default(0)
  averageScore      Float     @default(0)
  bestScore         Float     @default(0)
  currentStreak     Int       @default(0) // Consecutive days trained
  longestStreak     Int       @default(0)
  currentDifficulty Json? // Adaptive difficulty state
  lastSessionAt     DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  trainingModule TrainingModule @relation(fields: [trainingModuleId], references: [id])

  // Ensure one progress record per user per training module
  @@unique([userId, trainingModuleId])
  @@index([userId, trainingModuleId])
}

// ============================================================================
// CORE MODEL 5: CONTENT USAGE
// ============================================================================
// Tracks content shown to users for smart exclusion algorithm
// Prevents showing same words/images/audio in consecutive sessions
model ContentUsage {
  id          String   @id @default(cuid())
  userId      String
  contentType String // "word", "image", "audio"
  items       Json // Array of content items shown in session
  usedAt      DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Critical index for exclusion queries: "get content NOT in last 3 sessions"
  @@index([userId, contentType, usedAt])
}

// ============================================================================
// NEXTAUTH V5 MODELS
// ============================================================================

// OAuth account linking (Google, GitHub, etc.)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// User sessions
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Email verification tokens
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
